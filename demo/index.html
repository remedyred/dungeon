<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>@snickbit/dungeon</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
	<script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

	<style>
		canvas {
			margin: 0 auto 0;
			display: block;
			image-rendering: pixelated;
		}

		#seed {
			color: white;
			font-family: monospace;
			text-align: center;
			font-size: 1.5rem;
			cursor: copy;
		}
	</style>
	<title>Hello, world!</title>
</head>
<body>

<nav class="container-fluid">
	<ul>
		<li><a href="./" class="contrast"><strong>@snickbit/dungeon</strong></a></li>
	</ul>
	<ul>
		<li><strong id="seed"></strong></li>
	</ul>
	<ul>
		<li>
			<button id="generate"><strong>Generate</strong></button>
		</li>
		<li>
			<a href="https://github.com/snickbit/dungeon" target="_blank" class="contrast"><strong>GitHub</strong></a>
		</li>
	</ul>
</nav>


<main class="container">
	<section>
		<section id="dungeon" aria-busy="true"></section>
	</section>
</main>
<script src="../dist/index.bundle.js"></script>
<script>
	const options = {
		width: 21,
		height: 21,
		cellSize: 50,
		gridPadding: 0,
		removeDeadEnds: false,
		// seed: 'juicy-spoiled-table'
	}

	const $builder = window.createBuilder()
	const $dungeon = document.getElementById('dungeon')
	const $generate = document.getElementById('generate')
	const $seed = document.getElementById('seed')

	options.canvasWidth = options.width * options.cellSize
	options.canvasHeight = options.height * options.cellSize

	function start() {
		console.log('start')
		const $canvas = $dungeon.querySelector('canvas')
		if ($canvas) {
			$canvas.remove()
		}
		$dungeon.setAttribute('aria-busy', 'true')
	}

	function stop() {
		console.log('stop')
		$dungeon.setAttribute('aria-busy', 'false')
	}

	function generate() {
		start()
		console.log('waiting for dungeon to generate...')
		$builder.build(options).then(generated_dungeon => {
			console.log('Generated dungeon', generated_dungeon)

			stop()
			drawMap(generated_dungeon)

			// set the seed
			$seed.innerText = generated_dungeon.seed
		})
	}

	function drawMap(generated_dungeon) {
		$dungeon.innerHTML = '<canvas></canvas>'

		const $canvas = document.querySelector('canvas')
		const ctx = $canvas.getContext('2d')
		ctx.imageSmoothingEnabled = false

		$canvas.width = options.canvasWidth
		$canvas.height = options.canvasHeight

		$canvas.style.width = `${options.canvasWidth}px`
		$canvas.style.height = `${options.canvasHeight}px`

		// Fill canvas with black background
		ctx.fillStyle = 'gray'
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)

		// Blue for rooms
		ctx.fillStyle = '#6479a3'
		for (const room of generated_dungeon.rooms) {
			ctx.fillRect(room.x * options.cellSize, room.y * options.cellSize, room.width * options.cellSize, room.height * options.cellSize)
		}

		for (let x = 0; x < generated_dungeon.tiles.length; x++) {
			for (let y = 0; y < generated_dungeon.tiles[x].length; y++) {
				const tile = generated_dungeon.tiles[x][y]

				if (tile.isRoom()) {
					// Use an overlay for corridors
					ctx.fillStyle = '#3d5986'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				} else if (tile.isCorridor()) {
					// Use an overlay for corridors
					ctx.fillStyle = '#bdb8af'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				} else if (tile.isDoor()) {
					// White for doors
					ctx.fillStyle = 'white'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				} else if (tile.type === 'floor') {
					// Color missing tiles red
					ctx.fillStyle = 'red'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				}

				ctx.fillStyle = 'black'
				ctx.textAlign = 'center'

				const xPos = x * options.cellSize + options.cellSize / 2

				ctx.fillText(tile.name, xPos, y * options.cellSize + 10)

				let subtext = `[${tile.type?.substring(0, 1).toUpperCase()}]`
				if (tile.regionType) {
					subtext += ` [${tile.regionType?.substring(0, 1).toUpperCase()}]`
				}
				ctx.fillText(subtext, xPos, y * options.cellSize + 22)

				if (tile.region > -1) {
					ctx.fillText(`${tile.region}`, xPos, y * options.cellSize + 35)
				}
			}
		}

		// Draw the grid
		drawGrid(ctx)
	}

	function drawGrid(context) {
		for (let x = 0; x <= options.canvasWidth; x += options.cellSize) {
			context.moveTo(x + options.gridPadding, options.gridPadding)
			context.lineTo(x + options.gridPadding, options.canvasHeight + options.gridPadding)
		}

		for (let x = 0; x <= options.canvasHeight; x += options.cellSize) {
			context.moveTo(options.gridPadding, x + options.gridPadding)
			context.lineTo(options.canvasWidth + options.gridPadding, x + options.gridPadding)
		}
		context.strokeStyle = 'black'
		context.stroke()
	}


	window.addEventListener('load', (event) => {
		console.log('page is fully loaded')
		generate()
	})

	$generate.addEventListener('click', (event) => {
		generate()
	})
</script>
</body>
</html>
