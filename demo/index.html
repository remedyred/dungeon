<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>@snickbit/dungeon</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
	<script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>

	<style>
		canvas {
			margin: 0 auto 0;
			display: block;
			image-rendering: pixelated;
		}

		#seed {
			color: white;
			font-family: monospace;
			text-align: center;
			font-size: 1.5rem;
			cursor: copy;
		}
	</style>
	<title>Hello, world!</title>
</head>
<body>

<nav class="container-fluid">
	<ul>
		<li><a href="./" class="contrast"><strong>@snickbit/dungeon</strong></a></li>
	</ul>
	<ul>
		<li><strong id="seed"></strong></li>
	</ul>
	<ul>
		<li><button x-data x-on:click="createMap"><strong>Generate</strong></button></li>
		<li><a href="https://github.com/snickbit/dungeon" target="_blank" class="contrast"><strong>GitHub</strong></a></li>
	</ul>
</nav>


<main class="container">
	<section>
		<canvas></canvas>
	</section>
</main>
<script src="../dist/index.bundle.js"></script>
<script>
	const options = {
		width: 15,
		height: 15,
		cellSize: 40,
		gridPadding: 0
	}

	options.canvasWidth = options.width * options.cellSize;
	options.canvasHeight = options.height * options.cellSize;

	const $canvas = document.querySelector('canvas')
	const ctx = $canvas.getContext('2d')

	ctx.imageSmoothingEnabled = false

	function createMap() {
		const $dungeon = window.dungeon().build(options)

		console.log('Generated dungeon', $dungeon)

		$canvas.width = options.canvasWidth
		$canvas.height = options.canvasHeight

		$canvas.style.width = `${options.canvasWidth}px`
		$canvas.style.height = `${options.canvasHeight}px`

		// Fill canvas with black background
		ctx.fillStyle = 'black'
		ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)

		// Blue for rooms
		ctx.fillStyle = '#6479a3'
		for (const room of $dungeon.rooms) {
			ctx.fillRect(room.x * options.cellSize, room.y * options.cellSize, room.width * options.cellSize, room.height * options.cellSize)
		}

		for (let x = 0; x < $dungeon.tiles.length; x++) {
			for (let y = 0; y < $dungeon.tiles[x].length; y++) {
				const tile = $dungeon.tiles[x][y]

				if (tile.isRoom()) {
					// Use an overlay for corridors
					ctx.fillStyle = '#3d5986'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				} else if (tile.isCorridor()) {
					// Use an overlay for corridors
					ctx.fillStyle = '#bdb8af'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				} else if (tile.isDoor()) {
					// White for doors
					ctx.fillStyle = 'white'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				} else if (tile.type === 'floor') {
					// Color missing tiles red
					ctx.fillStyle = 'red'
					ctx.fillRect(x * options.cellSize, y * options.cellSize, options.cellSize, options.cellSize)
				}

				ctx.fillStyle = 'black'
				ctx.textAlign = 'center'
				ctx.fillText(`${x}x${y}`, x * options.cellSize + 18, y * options.cellSize + 10)

				if (tile.region > -1) {
					ctx.fillText(`${tile.region}`, x * options.cellSize + 18, y * options.cellSize + 30)
				}
			}
		}

		// Draw the grid
		drawGrid(ctx)

		const $seed = document.getElementById('seed')
		$seed.innerText = $dungeon.seed
	}

	function drawGrid(context) {
		for (let x = 0; x <= options.canvasWidth; x += options.cellSize) {
			context.moveTo(x + options.gridPadding, options.gridPadding)
			context.lineTo(x + options.gridPadding, options.canvasHeight + options.gridPadding)
		}

		for (let x = 0; x <= options.canvasHeight; x += options.cellSize) {
			context.moveTo(options.gridPadding, x + options.gridPadding)
			context.lineTo(options.canvasWidth + options.gridPadding, x + options.gridPadding)
		}
		context.strokeStyle = 'black'
		context.stroke()
	}

	document.addEventListener('alpine:initialized', () => {
		createMap()
	})

</script>
</body>
</html>
